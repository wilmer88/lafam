package nacl

import (
	"bytes"
	"crypto/rand"
	"testing"

	"golang.org/x/crypto/nacl/auth"
)

func TestSigner(t *testing.T) {
	var secretKey [32]byte
	if _, err := rand.Reader.Read(secretKey[:]); err != nil {
		t.Fatal("unexpected error", err)
	}

	s := NewSigner(&secretKey)
	data := []byte("hello world")
	expectedSum := auth.Sum(data, &secretKey)

	t.Run("sign", func(t *testing.T) {
		tests := []struct {
			name      string
			data      []byte
			wantEqual bool
		}{
			{
				name:      "happy path",
				data:      []byte("hello world"),
				wantEqual: true,
			},
			{
				name:      "wrong sum",
				data:      []byte("hola mundo"),
				wantEqual: false,
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				gotSum := s.Sign(test.data)
				gotEqual := bytes.Equal(expectedSum[:], gotSum)

				if test.wantEqual != gotEqual {
					t.Fatalf("wanted byte equality: %v, got %v", test.wantEqual, gotEqual)
				}
			})
		}
	})

	t.Run("verify", func(t *testing.T) {
		tests := []struct {
			name      string
			sum       []byte
			wantValid bool
		}{
			{
				name:      "happy path",
				sum:       expectedSum[:],
				wantValid: true,
			},
			{
				name:      "wrong sum",
				sum:       []byte("hax0r"),
				wantValid: false,
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				gotValid := s.Verify(test.sum, data)
				if test.wantValid != gotValid {
					t.Fatalf("wanted valid: %v, got %v", test.wantValid, gotValid)
				}
			})
		}
	})
}

func TestMultiSigner(t *testing.T) {
	var secretKey1 [32]byte
	if _, err := rand.Reader.Read(secretKey1[:]); err != nil {
		t.Fatal("unexpected error", err)
	}

	var secretKey2 [32]byte
	if _, err := rand.Reader.Read(secretKey2[:]); err != nil {
		t.Fatal("unexpected error", err)
	}

	data := []byte("hello world")
	expectedSum1 := auth.Sum(data, &secretKey1)
	expectedSum2 := auth.Sum(data, &secretKey2)

	s := NewMultiSigner(NewSigner(&secretKey1), NewSigner(&secretKey2))

	t.Run("sign", func(t *testing.T) {
		tests := []struct {
			name      string
			sum       []byte
			wantEqual bool
		}{
			{
				name:      "sum generated via new key",
				sum:       expectedSum1[:],
				wantEqual: true,
			},
			{
				name:      "sum generated via old key",
				sum:       expectedSum2[:],
				wantEqual: false,
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				gotSum := s.Sign(data)

				gotEqual := bytes.Equal(test.sum, gotSum)
				if test.wantEqual != gotEqual {
					t.Fatalf("wanted equal: %v, got %v", test.wantEqual, gotEqual)
				}
			})
		}

	})

	t.Run("verify", func(t *testing.T) {
		tests := []struct {
			name      string
			sum       []byte
			wantValid bool
		}{
			{
				name:      "sum generated via new key",
				sum:       expectedSum1[:],
				wantValid: true,
			},
			{
				name:      "sum generated via old key",
				sum:       expectedSum2[:],
				wantValid: true,
			},
			{
				name:      "sum generated by hax0r",
				sum:       []byte("hax hax hax"),
				wantValid: false,
			},
		}

		for _, test := range tests {
			t.Run(test.name, func(t *testing.T) {
				gotValid := s.Verify(test.sum, data)
				if test.wantValid != gotValid {
					t.Fatalf("wanted valid: %v, got %v", test.wantValid, gotValid)
				}
			})
		}
	})
}
